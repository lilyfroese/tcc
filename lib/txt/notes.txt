banco de dados 

1. Banco de dados padrão de cadastro - CRUD

2. Sistema de banco de dados de metas - CRUD
  2.1 O cadastro de metas tem que estar ligado ao numero de
  peças de quebra cabeça que estarão apresentados.
  2.2 As cores não podem mais ser aleatórias, elas tem que ser de 
  acordo com o que foi cadastrado no adicionar metas 
  2.3 As peças de quebra cabeça também precisam obter ícones de
  representação para que o usuário consiga saber com mais facilidade
  sobre o que a meta se trata. 
  2.4 Cada ícone deve estar interligado a uma animação, um banco de
  armazém de animação.
  2.5 Armazenagem de feitos e não feitos 

- SE DER TEMPO-
3. Sistema de animação 
  3.1 O sistema de animação precisa ter cada animação interligada a
  um ícone, como por exemplo como já criado ícone de bolha com a
  a animação de bolha já criada. 

4. Banco de dados de sentimentos 
 4.1 Será necessario um banco de dados para o armazem de sentimentos
 de cada usuario de acordo com o que ele registra em registrar humor
 (atual freud score)
 4.2 Na mesma linha será necessaop a criação de um banco de dados
 para a armazenagem de desabafos 

5. Sistema de graficos de progresso do aluno 
  5.1 grafico de progresso


PONTOS A FAZER 

2.1 preciso arrumar a fixação de peças na tela principal.
2.5 realizar uma mensagem pup para aparecer na tela de realizar 
e não realizar meta.

goal 


import 'package:flutter/material.dart';
import 'dart:math';

/// ==============================
/// Lista de ícones (use a sua)
/// ==============================
final List<IconData> icones = [
  Icons.bubble_chart,
  Icons.nightlight_round,
  Icons.local_florist,
  Icons.menu_book,
  Icons.fitness_center,
  Icons.star,
  Icons.favorite,
];

/// ==================================================
/// PuzzleGoal — recebe lista de metas (cada meta = Map)
/// ==================================================
class PuzzleGoal extends StatelessWidget {
  final List<dynamic> metas; // cada meta: Map (title, color, icon index, ...)
  final void Function(dynamic /*meta*/)? onPieceTap;
  final double verticalPaddingBottom;

  const PuzzleGoal({
    super.key,
    required this.metas,
    this.onPieceTap,
    this.verticalPaddingBottom = 20.0,
  });

  @override
  Widget build(BuildContext context) {
    final totalPieces = metas.length;
    if (totalPieces == 0) {
      return const Center(child: Text('Nenhuma meta cadastrada'));
    }

    final dimensions = _calculateGridDimensions(totalPieces);
    final rows = dimensions.item1;
    final columns = dimensions.item2;

    return LayoutBuilder(
      builder: (context, constraints) {
        const horizontalPadding = 20.0;
        final verticalPaddingTop = max(10.0, 60.0 - rows * 5);

        final maxWidthArea = constraints.maxWidth - 2 * horizontalPadding;
        final maxHeightArea = constraints.maxHeight - verticalPaddingTop - verticalPaddingBottom;

        final maxPieceWidth = maxWidthArea / columns;
        final maxPieceHeight = maxHeightArea / rows;

        final pieceSize = min(maxPieceWidth, maxPieceHeight);
        final puzzleWidth = pieceSize * columns;
        final puzzleHeight = pieceSize * rows;

        return Padding(
          padding: EdgeInsets.fromLTRB(
            horizontalPadding,
            verticalPaddingTop,
            horizontalPadding,
            verticalPaddingBottom,
          ),
          child: Align(
            alignment: Alignment.topCenter,
            child: SizedBox(
              width: puzzleWidth,
              height: puzzleHeight,
              child: Stack(
                children: List.generate(totalPieces, (index) {
                  final row = index ~/ columns;
                  final column = index % columns;

                  final top = row == 0 ? SideType.flat : (row % 2 == 0 ? SideType.outward : SideType.inward);
                  final bottom = row == rows - 1 ? SideType.flat : (row % 2 == 0 ? SideType.inward : SideType.outward);
                  final left = column == 0 ? SideType.flat : (column % 2 == 0 ? SideType.outward : SideType.inward);
                  final right = column == columns - 1 ? SideType.flat : (column % 2 == 0 ? SideType.inward : SideType.outward);

                  // pega a meta do backend
                  final meta = metas[index] as Map<String, dynamic>;
                  // converte color hex string "#RRGGBB" para Color
                  final Color pieceColor = _colorFromString(meta['color'] ?? '#AABBCC');
                  // pega ícone por índice (segurança)
                  final int iconIndex = (meta['icon'] is int) ? meta['icon'] as int : int.tryParse('${meta['icon']}') ?? 0;
                  final IconData iconData = (iconIndex >= 0 && iconIndex < icones.length) ? icones[iconIndex] : Icons.extension;

                  return Positioned(
                    left: column * pieceSize,
                    top: row * pieceSize,
                    width: pieceSize,
                    height: pieceSize,
                    child: GestureDetector(
                      onTap: () => onPieceTap?.call(meta),
                      child: PuzzlePieceWidget(
                        // mantém sua API antiga, só adiciona icon + pieceColor
                        index: index,
                        row: row,
                        column: column,
                        rows: rows,
                        columns: columns,
                        top: top,
                        bottom: bottom,
                        left: left,
                        right: right,
                        icon: iconData,
                        pieceColor: pieceColor,
                      ),
                    ),
                  );
                }),
              ),
            ),
          ),
        );
      },
    );
  }

  Tuple2<int, int> _calculateGridDimensions(int count) {
    switch (count) {
      case 2:
        return Tuple2(2, 1);
      case 4:
        return Tuple2(2, 2);
      case 6:
        return Tuple2(3, 2);
      case 8:
        return Tuple2(4, 2);
      case 10:
        return Tuple2(5, 2);
      case 12:
        return Tuple2(4, 3);
      case 14:
        return Tuple2(7, 2);
      case 16:
        return Tuple2(4, 4);
      case 18:
        return Tuple2(6, 3);
      case 20:
        return Tuple2(5, 4);
      case 24:
        return Tuple2(6, 4);
      case 28:
        return Tuple2(7, 4);
      case 30:
        return Tuple2(6, 5);
      case 32:
        return Tuple2(8, 4);
      default:
        return Tuple2(count, 1);
    }
  }
}

/// =======================================
/// PuzzlePieceWidget — desenha peça + ícone
/// =======================================
class PuzzlePieceWidget extends StatelessWidget {
  final int index;
  final int row, column;
  final int rows, columns;
  final SideType top, bottom, left, right;

  // novos
  final IconData icon;
  final Color pieceColor;

  const PuzzlePieceWidget({
    super.key,
    required this.index,
    required this.row,
    required this.column,
    required this.rows,
    required this.columns,
    required this.top,
    required this.bottom,
    required this.left,
    required this.right,
    required this.icon,
    required this.pieceColor,
  });

  @override
  Widget build(BuildContext context) {
    // usamos Stack para desenhar a peça e sobrepor o ícone central
    return Stack(
      alignment: Alignment.center,
      children: [
        CustomPaint(
          painter: PuzzlePiecePainter(
            color: pieceColor,
            top: top,
            bottom: bottom,
            left: left,
            right: right,
          ),
          child: Container(),
        ),

        // ícone central (branco para contraste)
        Icon(
          icon,
          size: min(28.0, MediaQuery.of(context).size.width * 0.045),
          color: Colors.white.withOpacity(0.95),
        ),
      ],
    );
  }
}

/// =======================================
/// Painter (mantive seu painter original, só limpei e comentei)
/// =======================================
class PuzzlePiecePainter extends CustomPainter {
  final Color color;
  final SideType top, bottom, left, right;

  PuzzlePiecePainter({
    required this.color,
    required this.top,
    required this.bottom,
    required this.left,
    required this.right,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final path = Path();

    final w = size.width;
    final h = size.height;
    final knobSize = min(w, h) * 0.2;

    path.moveTo(0, 0);

    _drawSide(path, w, 0, Side.top, top, knobSize);
    _drawSide(path, h, w, Side.right, right, knobSize);
    _drawSide(path, w, h, Side.bottom, bottom, knobSize);
    _drawSide(path, h, 0, Side.left, left, knobSize);

    path.close();

    final paint = Paint()
      ..shader = LinearGradient(
        colors: [_darken(color, 0.25), _lighten(color, 0.08)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));

    canvas.drawPath(path, paint);
  }

  void _drawSide(Path path, double length, double offset, Side side, SideType type, double knobSize) {
    double third = length / 3;

    switch (side) {
      case Side.top:
        path.lineTo(third, 0);
        _drawKnob(path, Offset(third, 0), Offset(2 * third, 0), type, true);
        path.lineTo(length, 0);
        break;
      case Side.right:
        path.lineTo(offset, third);
        _drawKnob(path, Offset(offset, third), Offset(offset, 2 * third), type, false);
        path.lineTo(offset, length);
        break;
      case Side.bottom:
        path.lineTo(length - third, offset);
        _drawKnob(path, Offset(length - third, offset), Offset(third, offset), type, true, reverse: true);
        path.lineTo(0, offset);
        break;
      case Side.left:
        path.lineTo(0, length - third);
        _drawKnob(path, Offset(0, length - third), Offset(0, third), type, false, reverse: true);
        path.lineTo(0, 0);
        break;
    }
  }

  void _drawKnob(Path path, Offset from, Offset to, SideType type, bool horizontal, {bool reverse = false}) {
    if (type == SideType.flat) {
      path.lineTo(to.dx, to.dy);
      return;
    }

    final mid = Offset((from.dx + to.dx) / 2, (from.dy + to.dy) / 2);
    final knobRadius = (horizontal ? to.dx - from.dx : to.dy - from.dy) / 1.5;
    final knobDepth = (type == SideType.outward ? 1 : -1) * knobRadius;

    if (horizontal) {
      final direction = reverse ? -1 : 1;
      path.quadraticBezierTo(mid.dx, mid.dy + knobDepth * direction, to.dx, to.dy);
    } else {
      final direction = reverse ? -1 : 1;
      path.quadraticBezierTo(mid.dx + knobDepth * direction, mid.dy, to.dx, to.dy);
    }
  }

  Color _darken(Color color, [double amount = .2]) {
    final hsl = HSLColor.fromColor(color);
    return hsl.withLightness((hsl.lightness - amount).clamp(0.0, 1.0)).toColor();
  }

  Color _lighten(Color color, [double amount = .2]) {
    final hsl = HSLColor.fromColor(color);
    return hsl.withLightness((hsl.lightness + amount).clamp(0.0, 1.0)).toColor();
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}

/// =======================
/// enums e util
/// =======================
enum SideType { flat, inward, outward }
enum Side { top, bottom, left, right }

class Tuple2<T1, T2> {
  final T1 item1;
  final T2 item2;
  Tuple2(this.item1, this.item2);
}

/// =======================
/// Helpers
/// =======================
Color _colorFromString(String hex) {
  hex = hex.replaceAll('#', '');
  if (hex.length == 6) hex = 'FF$hex';
  return Color(int.parse(hex, radix: 16));
}



